apiVersion: eksctl.io/v1alpha5
kind: ClusterConfig

metadata:
  name: funcx-dev
  region: us-east-1

cloudWatch:
  clusterLogging:
    # enable specific types of cluster control plane logs
    enableTypes: ["all"]

vpc:
  id: vpc-0d3b9f7c3a9c6c1ba
  subnets:
    public:
      us-east-1a:
        id: subnet-0c0d6b32bb57c39b2
      us-east-1b:
        id: subnet-0906da1c44cbe3b8d
    private:
      us-east-1a:
        id: subnet-0e79de4daf8cf321f
      us-east-1b:
        id: subnet-0d10f5ed0f8099b91

iam:
  withOIDC: true
  serviceAccounts:
    - metadata:
        name: aws-load-balancer-controller
        namespace: kube-system
      wellKnownPolicies:
        awsLoadBalancerController: true
        certManager: true
    - metadata:
        name: funcx-service
        namespace: default
      attachPolicy:
        Version: "2012-10-17"
        Statement:
          - Sid: S3Access
            Effect: Allow
            Action: 
              - s3:PutObject
              - s3:GetObject
              - s3:ListObject
            Resource: arn:aws:s3:::funcx-dev-task-storage/*

addons:
  - name: vpc-cni

nodeGroups:
  - name: funcx-dev-node-group
    instanceType: t3.medium
    desiredCapacity: 2
    volumeSize: 20
    ssh:
      publicKeyName: funcx-eks
      enableSsm: true
    availabilityZones:
      - us-east-1a
      - us-east-1b
    iam:
      withAddonPolicies:
        autoScaler: true
        externalDNS: true
        certManager: true
        albIngress: true
        cloudWatch: true

  - name: repo2docker-node-group
    instanceType: t3.medium
    desiredCapacity: 2
    volumeSize: 20
    labels: { role: repo2docker }
    ssh:
      publicKeyName: funcx-eks
      enableSsm: true
    availabilityZones:
      - us-east-1a
      - us-east-1b
    iam:
      withAddonPolicies:
        autoScaler: true
        externalDNS: true
        certManager: true
        albIngress: true
        cloudWatch: true
    preBootstrapCommands:
        # This is needed to allow repo2docker to build inside a kubernetes
        # pod. Without it, the build fails because the AWS DNS Server won't
        # allow the weird internal IP address access.
        # From:
        #    https://discourse.jupyter.org/t/binder-deployed-in-aws-eks-domain-name-resolution-errors/766/11
        # Replicate what --enable-docker-bridge does in /etc/eks/bootstrap.sh
        # Enabling the docker bridge network. We have to disable live-restore as it
        # prevents docker from recreating the default bridge network on restart
       - "cp /etc/docker/daemon.json /etc/docker/daemon_backup.json"
       - "echo -e '.bridge=\"docker0\" | .\"live-restore\"=false' >  /etc/docker/jq_script"
       - "jq -f /etc/docker/jq_script /etc/docker/daemon_backup.json | tee /etc/docker/daemon.json"
       - "systemctl restart docker"
